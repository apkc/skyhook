import axios from "axios";
import jwtDecode from "jwt-decode";



/*
request is a method decorator for API calls that accepts
an HTTP method and URI to generate a request to the admin API
of a Skyhook deployment.

# Base URL

The base URL for the request is read from the instance's base_url
property.

Trailing slashes are removed from the URL prior to the request.

# Output Object

Callers to the decorated class methods receive a consistent
object in the form of:

{
  ok: boolean,
  resp: axios.response,
  output: object,
}

Where output is any additional output generated by the decorated
class method.
 */
function request(httpMethod, uri) {
    function outer(target) {
        async function decorator(data) {
            try {
                //======================
                // CHECK THE HTTP METHOD
                //======================

                if (axios[httpMethod] === undefined) {
                    throw new Error(`Invalid HTTP method supplied: ${httpMethod}`);
                }

                //===========================
                // TRIM SLASHES FROM BASE URL
                //===========================

                let base_url = (this.base_url === undefined ? "" : this.base_url)

                if(base_url[base_url.length-1]==="/"){
                    let i=base_url.length-1;
                    for(i; i>=0; i--){
                        if(base_url[i] !== "/"){
                            break
                        }
                        base_url=base_url.slice(0, i)
                    }
                }

                //=================
                // MAKE THE REQUEST
                //=================

                let resp = await axios.request({
                    url: base_url+uri,
                    method: httpMethod,
                    headers: this.headers(),
                    data: data
                }).catch((e) => {
                    return e.response;
                })

                //=================================
                // CALL DECORATED METHOD FOR OUTPUT
                //=================================

                let output = target.call(this, data, resp)

                //==================
                // RETURN THE OUTPUT
                //==================

                return {
                    ok: resp.status === 200,
                    resp: resp,
                    output: output
                }

            } catch (e) {

                console.log(`Decorator failed to execute method ${target.name}: ${e}`)
                throw e;

            }
        }
        return decorator;
    }
    return outer;
}

export class AdminApi {

    constructor(base_url, headers, realm, username_field_name, admin_field_name, auth_header_name, auth_header_scheme){

        this.mgr = new AuthMgr(this, "json_token", "jwt", "token")
        this.token = this.mgr.token;

        this.base_url = (!base_url ? window.location.origin : base_url)
        this._headers = (headers === undefined ? {} : headers)
        this._headers = Object.assign(this.headers, {
            "Accept": "application/json",
            "Content-Type": "application/json",
        })

        //=============================
        // SET JWT & AUTH HEADER FIELDS
        //=============================

        let api_config = localStorage.getItem("api_config")
        if(api_config){
            api_config = JSON.parse(api_config);
            this.setApiConfig(api_config);
        } else {
            this.realm_value = (!realm ? "sh" : realm)
            this.username_field_name = (!realm ? "id" : username_field_name)
            this.admin_field_name = (!admin_field_name ? "ad" : admin_field_name)
            this.auth_header_name = (!auth_header_name ? "Authorization" : auth_header_name)
            this.auth_header_scheme = (!auth_header_scheme ? "Bearer" : auth_header_scheme)
        }

        //============================================
        // METHOD BINDINGS (OR WHATEVER THIS TRASH IS)
        //============================================

        this.login = this.login.bind(this);
        this.postLogout = this.postLogout.bind(this);
        this.getPing = this.getPing.bind(this);
        this.getAdminPing = this.getAdminPing.bind(this);
        this.getRefreshToken = this.getRefreshToken.bind(this);
        this.getUsers = this.getUsers.bind(this);
        this.putUsers = this.putUsers.bind(this);
        this.getObfsAvail = this.getObfsAvail.bind(this);
        this.getObfsConfig = this.getObfsConfig.bind(this);
        this.putObfsConfig = this.putObfsConfig.bind(this);
        this.setApiConfig = this.setApiConfig.bind(this);
    }

    headers(){
        let headers = Object.assign({}, this._headers)
        if(this.token !== "") {
            headers[this.auth_header_name] = `${this.auth_header_scheme} ${this.token}`
        }
        return headers
    }

    setApiConfig(api_config){
        this.realm_value = api_config.auth_config.jwt.realm;
        this.username_field_name = api_config.auth_config.jwt.username;
        this.admin_field_name = api_config.auth_config.jwt.admin;
        this.auth_header_name = api_config.auth_config.header.name;
        this.auth_header_scheme = api_config.auth_config.header.scheme;
    }

    //=====================
    // AUTHENTICATION CALLS
    //=====================

    @request("post", "/login")
    login(data, resp){
        let alert;
        if(resp.status === 200){

            this.token = resp.data.token;
            let api_config = this.mgr.jwtDecodeToken(this.token);
            if(api_config){
                this.setApiConfig(api_config);
                this.mgr.updateStoredTokens(resp.data);
            }

            alert = {variant:"success",
                heading: "",
                message: "Login successful",
                timeout: 5}

        } else {
            alert = {
                variant: "warning",
                heading: "",
                message: "Login failure",
                timeout: 5
            }
        }
        return {
            token: this.mgr.jwt,
            alert: alert
        }
    }

    @request("get", "/login")
    getRefreshToken(data, response){
        let alert;
        if(response.status !== 200){
            alert = {
                variant: "danger",
                heading: "",
                message: "Failed to refresh login token",
                timeout: 10,
            }
        }
        return {
            token: response.data,
            alert: alert
        }
    }

    @request("post", "/logout")
    postLogout(data, response){
        let alert = {
            variant: "success",
            heading: "",
            message: "Logout sucessful.",
            timeout: 10,
            show: true,
        }
        if(response.status === 200){
            this.mgr.clearStoredTokens()
        } else {
            alert = {
                variant: "danger",
                message: "Logout failed.",
                timeout: 10,
                show: true,
            }
        }
        return {alert: alert}
    }

    //===========
    // MISC CALLS
    //===========

    @request("get", "/ping")
    getPing(data, response){
        if(response.status === 200){
            return {success: true}
        } else {
            return {
                success: false,
                alert: {
                    variant: "danger",
                    heading: "Failed to Ping API",
                    message: `HTTP status code: ${response.status}`,
                    timeout: 5,
                    show: true
                }
            }
        }
    }

    @request("get", "/admin/ping")
    getAdminPing(data, response){
        if(response.status === 200){
            return {success: true}
        } else {
            return {
                success: false,
                alert: {
                    variant: "danger",
                    heading: "Failed to Ping Admin API",
                    message: `HTTP status code: ${response.status}`,
                    timeout: 5,
                    show: true
                }
            }
        }
    }

    @request("get", "/admin/links")
    getAdminLinks(data, response){
        if(response.status===200){
            return {
                success:true,
                links: response.data
            }
        } else {
            return {
                success: false,
                alert: {
                    variant: "danger",
                    heading: "Failed to retrieve API links",
                    message: `HTTP status code: ${response.status}`,
                    timeout: 5,
                    show: true
                }
            }
        }
    }

    @request("get", "/admin/js")
    getEncryptedJs(data, response){
        debugger
        if(response.status===200){
            return {
                success:true,
                encrypted_js: response.data.encrypted_js
            }
        } else {
            return {
                success: false,
                alert: {
                    variant: "danger",
                    heading: "Failed to retrieve encrypted JS data",
                    message: `HTTP status code: ${response.status}`,
                    timeout: 5,
                    show: true
                }
            }
        }
    }

    //======================
    // USER MANAGEMENT CALLS
    //======================

    @request("get", "/admin/users")
    getUsers(data, response) {
        if(response.status === 200){
            return {
                success: true,
                users: response.data.users
            }
        } else {
            return {
                success: false,
                alert: {
                    variant: "danger",
                    heading: "Failed to Get Users",
                    message: `HTTP status code: ${response.status}`,
                    timeout: 5,
                    show: true
                }
            }
        }
    }

    @request("put", "/admin/users")
    putUsers(data, response) {
        if(response.status === 200){
            return {
                success: true,
            }
        } else {
            return {
                success: false,
                alert: {
                    variant: "danger",
                    heading: "Failed to Create User",
                    message: `HTTP status code: ${response.status}`,
                    timeout: 5,
                    show: true
                }
            }
        }
    }

    //=================
    // OBFUSCATOR CALLS
    //=================

    @request("get", "/admin/obfs")
    getObfsAvail(data, response) {
        if(response.status === 200){
            return {
                success: true,
                obfuscators: response.data.obfuscators
            }
        } else {
            return {
                success: false,
                alert: {
                    variant: "danger",
                    heading: "Failed to Get Obfuscators",
                    message: `HTTP status code: ${response.status}`,
                    timeout: 5,
                    show: true
                }
            }
        }
    }

    @request("get", "/admin/obfs/config")
    getObfsConfig(data, response) {
        if(response.status === 200){
            return {
                success: true,
                obfuscators: response.data.obfuscators
            }
        } else {
            return {
                success: false,
                alert: {
                    variant: "danger",
                    heading: "Failed to Get Obfuscators Configuration",
                    message: `HTTP status code: ${response.status}`,
                    timeout: 5,
                    show: true
                }
            }
        }
    }

    @request("put", "/admin/obfs/config")
    putObfsConfig(data, response) {
        if(response.status === 200){
            return {
                success: true,
            }
        } else {
            return {
                success: false,
                alert: {
                    variant: "danger",
                    heading: "Failed to Update Obfuscators Configuration",
                    message: `HTTP status code: ${response.status}`,
                    timeout: 5,
                    show: true
                }
            }
        }
    }

    @request("get", "/admin/advanced")
    getAdvancedConfig(data, response){
        if(response.status === 200){
            return response.data
        } else {
            return {
                success: false,
                alert: {
                    variant: "danger",
                    heading: "Failed to get Advanced Configuration",
                    message: `HTTP status code: ${response.status}`,
                    timeout: 5,
                    show: true
                }
            }
        }
    }

    @request("get", "/admin/landing")
    getFileServerLandingUri(data, response){
        if(response.status === 200){
            return response.data.msg
        } else {
            return {
                success: false,
                alert: {
                    variant: "danger",
                    heading: "Failed to get File Server Landing URI",
                    message: `HTTP status code: ${response.status}`,
                    timeout: 5,
                    show: true
                }
            }
        }
    }
}

class AuthMgr {

    constructor(admin, json_storage_key, jwt_storage_key, token_storage_key){

        // this.admin is a reference to AdminApi, allowing us to
        // make the necessary API calls to refresh the token.
        this.admin = admin;

        // this.jwt is the decoded token
        this.jwt = null;

        // this.token is the raw string token (unencoded)
        this.token = null;

        // this.json_storage_key is the key used to pull the token
        // from local storage.
        this.json_storage_key = json_storage_key;

        // this.jwt_storage_key is the storage key for the decoded
        // JWT value.
        this.jwt_storage_key = jwt_storage_key;

        // this.token_storage_key is the storage key for the
        // string token value used for authentication.
        this.token_storage_key = token_storage_key;

        //==============================================
        // RETRIEVE JSON STRING TOKEN FROM LOCAL STORAGE
        //==============================================

        let jsonToken = localStorage.getItem(this.json_storage_key);
        if(jsonToken){
            try {
                jsonToken = JSON.parse(jsonToken);
                this.jwtDecodeToken(jsonToken.token)
            } catch(e) {
                console.log("Failed to parse JSON token from local storage.")
                console.log(e);
            }

            // NOTE: No token indicates that authentication should occur
            jsonToken = "";
        }

        //=========================================================
        // CONFIGURE EVENT LISTENER TO PULL NEW TOKENS FROM STORAGE
        //=========================================================

        window.addEventListener("storage", this.storageListener);
        setInterval(this.checkTokenExpiry, 60000);
    }
    
    async checkTokenExpiry(){
        if(!this.token){
            return
        }
        
        if(this.jwt != null){
            if(this.jwt.exp < (Date.now() - 1000 * 60 * 5) / 1000){
                let out = await this.admin.getRefreshToken();
                if(!out.ok){
                    // TODO alert on this event somehow
                    console.log(`Failed to refresh token`)
                    this.clearStoredTokens();
                } else {
                    this.admin.token = out.output.token.token;
                    this.updateStoredTokens(out.output.token);
                }
            }
        }
    }

    /*
    updateJsonStorageToken sets newToken in local storage when it has a value,
    otherwise the current token is removed from storage.
     */
    updateStoredTokens(newToken){
        if(newToken){
            let jToken;
            try {
                jToken = JSON.stringify(newToken);
            } catch(e) {
                console.log(`Failed to parse new JSON token: ${e}`);
                throw e;
            }
            localStorage.setItem(this.json_storage_key, jToken);
            localStorage.setItem(this.token_storage_key, newToken.token);
        } else {
            localStorage.removeItem(this.json_storage_key);
        }
    }

    clearStoredTokens(){
        this.token=null;
        this.admin.token=null;
        localStorage.removeItem(this.json_storage_key);
        localStorage.removeItem(this.token_storage_key);
    }

    storageListener(event){

        // Ensure the event is related to the token
        if(event.key !== this.json_storage_key){
            return
        }

        // Disregard empty tokens
        let json = event.newValue;
        if(!json){
            return
        }

        // Parse the token into an object from JSON
        try {
            json = JSON.parse(json)
        } catch(e) {
            console.log(`Failed to parse JWT token written to local storage: ${e}`);
            // TODO send an error alert
            return
        }

        // JWT decode the token and set it as an instance attribute
        if(this.jwtDecodeToken(json.token)){
            // If successful, pass it to update token
            this.updateStoredTokens(json);
        }
    }

    jwtDecodeToken(token){

        if(typeof(token) !== "string"){
            console.log("jwtDecodeToken expects a string.")
            return
        }

        // JWT decode the token
        let config;
        try{
            this.jwt = jwtDecode(token);

            //===========================================
            // DECRYPT THE REQUESTS CONFIG FROM THE TOKEN
            //===========================================

            let key = new TextEncoder().encode(localStorage.getItem("user_token"))

            let tAttrs = Object.keys(this.jwt);
            for(let i=0; i<tAttrs.length; i++){
                let a = tAttrs[i];
                try{
                    let raw = window.atob(this.jwt[a]);
                    config = new Uint8Array(raw.length);
                    for(let xi=0; xi<raw.length; xi++){
                        config[xi] = raw[xi].charCodeAt(0)^key[xi%key.byteLength]
                    }
                    config = new TextDecoder("utf8").decode(config);
                    config = JSON.parse(config);
                    if(config.obfuscators){
                        console.log("API config parsed from login response.");
                        console.log("Setting config in local storage.")
                        localStorage.setItem("api_config", JSON.stringify(config));
                        break
                    }
                }catch(e){
                    config="";
                    continue
                }
            }

            if(config === ""){
                throw new Error('Failed to parse API config from JWT token');
            }

            this.token = token;
        }catch(e){
            console.log(`Failed to decode JWT token: ${e}`);
            // TODO send an error alert
            return false;
        }

        return config;
    }
}

let SKYHOOK_SERVER;
if(process.env.NODE_ENV === 'development'){
    SKYHOOK_SERVER=process.env.REACT_APP_SKYHOOK_SERVER;
}
export const adminApi = new AdminApi(SKYHOOK_SERVER);